-- This lesson will entail designing a simple employee database with time
-- tracking along with writing queries to maintain and report on the employee
-- data.

-- Start by creating a table for employees.
create table employees (
  id int primary key generated by default as identity,
  first_name varchar not null,
  last_name varchar not null,
  hire_date date not null
);

-- Insert a few employee records.
insert into employees(first_name, last_name, hire_date) values ('John', 'Smith', '2018-05-23');
insert into employees(first_name, last_name, hire_date) values ('Abby', 'Miller', '2016-11-02');
insert into employees(first_name, last_name, hire_date) values ('Mary', 'Jones', '2018-03-31');
insert into employees(first_name, last_name, hire_date) values ('Sam', 'Stewart', '2017-04-15');

-- Exercise 1:
--   1.1 Write a query to find the newest employee.
--   1.2 Write a query to find the oldest employee.
--   1.3 Bonus: Write a query to find how long each person has been employed.
--   1.4 Bonus 2: Write a query to find the average tenure of employee.

-- How should we represent a period of time the employee is working?
--
-- How should we represent it when an employee has clocked-in but has not yet clocked-out?
--
-- Naming can be challenging... Work periods, shifts, hours worked, time clock entries...
create table worked_shifts (
  id int primary key generated by default as identity,
  employee_id int not null references employees,
  time_range tstzrange not null
);

-- Foreign keys should almost always be indexed.
-- https://www.postgresql.org/docs/13/sql-createindex.html
create index on worked_shifts (employee_id);

-- Insert our first shift.
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 09:00:00', '2018-09-14 14:00:00'));

-- Bonus - Ensure one employee cannot have overlapping shifts
-- https://www.postgresql.org/docs/13/sql-createextension.html
create extension btree_gist;
alter table worked_shifts add constraint prevent_overlapping_shifts exclude using gist (employee_id with =, time_range with &&);

-- Observe how database prevents any type of overlap.
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 09:00:00', '2018-09-14 14:00:00')); -- exact duplicate of existing
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 08:00:00', '2018-09-14 10:00:00')); -- overlaps beginning of existing
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 12:00:00', '2018-09-14 16:00:00')); -- overlaps end of existing
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 11:00:00', '2018-09-14 13:00:00')); -- entirely contained by existing
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 06:00:00', '2018-09-14 18:00:00')); -- entirely contains existing
insert into worked_shifts (employee_id, time_range) values (1, tstzrange('2018-09-14 06:00:00', null)); -- unbounded range that entirely contains existing

-- An in-progress shift is represented by an unbounded range.
insert into worked_shifts (employee_id, time_range) values (2, tstzrange('2018-09-18 09:00:00', null));

-- We can find in-progress shifts with the upper_inf() function.
select * from worked_shifts where upper_inf(time_range);

-- We can determine how long each shift was with lower() and upper() functions
select *, upper(time_range) - lower(time_range) as shift_length
from worked_shifts;

-- The PostgreSQL range documentation covers many useful operators and functions.
-- https://www.postgresql.org/docs/current/static/functions-range.html

-- Exercise 2:
--   2.1 Write a query to clock an employee in (hint: you need to insert a record).
--   2.2 Write a query to clock an employee out (hint: you need to update the previously inserted record).

-- We need some test data. Let's make PostgreSQL work for us. Don't worry if
-- some of the test data creation code is unfamiliar or difficult to understand
-- at this point.

-- First, delete any existing worked_shifts.
delete from worked_shifts;

-- The generate_series function can give us a table of timestamps for the last month.
-- https://www.postgresql.org/docs/13/functions-srf.html
select *
from generate_series(current_date - 30, current_date, '1 day') d;

-- We can join this with the employees table to get a record for each employee each day.
select *
from employees
  cross join generate_series(current_date - 30, current_date, '1 day') d;

-- The random function gives us a value between 0 and 1.
select random();

-- This can be scaled to 1 to X with a multiplication and ceil function.
select ceil(random() * 4);

-- Put these together with make_interval and random shifts starting between 6
-- and 10 AM and ending between 11 AM and 3 PM.
select employees.id, tstzrange(
  d + make_interval(hours => (5 + ceil(random() * 4))::int),
  d + make_interval(hours => (10 + ceil(random() * 4))::int)
)
from employees
  cross join generate_series(current_date - 30, current_date, '1 day') d;

-- But people don't generally work every day.
select employees.id, tstzrange(
  d + make_interval(hours => (5 + ceil(random() * 4))::int),
  d + make_interval(hours => (10 + ceil(random() * 4))::int)
)
from employees
  cross join generate_series(current_date - 30, current_date, '1 day') d
where random() > 0.2;

-- The result of a select can be inserted into a table.
insert into worked_shifts (employee_id, time_range)
select employees.id, tstzrange(
  d + make_interval(hours => (5 + ceil(random() * 4))::int),
  d + make_interval(hours => (10 + ceil(random() * 4))::int)
)
from employees
  cross join generate_series(current_date - 30, current_date, '1 day') d
where random() > 0.2;

-- Whew... With all that let's see how many hours in total have been worked.
select sum(upper(time_range) - lower(time_range))
from worked_shifts;

-- Exercise 3:
--   3.1 Write a query to compute how much each employee has worked. Include the employee's name.
--   3.2 Bonus 1: Write a query to compute how much each employee has worked in the last week. Include the employee's name.
--   3.3 Bonus 2 (very hard): Would an employee who had not worked in the last week appear in the results of exercise 3.2?
--       Insert a new employee who has not worked any hours. Then make the query used in 3.2 show the new employee
--       with 0 time worked.

-- How could we find employees who have worked more than N hours in aggregate?

-- The HAVING clause is like a WHERE that filters after the GROUP BY has occurred.
-- https://www.postgresql.org/docs/13/sql-select.html#SQL-HAVING
select last_name, first_name, sum(upper(time_range) - lower(time_range))
from worked_shifts
  join employees on employees.id=worked_shifts.employee_id
group by last_name, first_name
having sum(upper(time_range) - lower(time_range)) > '100:00:00';

-- Optional discussion:
--   * What happens when an employee leaves?
--   * Could a former employee be rehired?
--   * What if an employee forgot to sign out?
